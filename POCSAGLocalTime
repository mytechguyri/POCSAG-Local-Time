#!/usr/bin/env python3
import logging
from datetime import datetime, timedelta
import os
import glob 
import time
import subprocess

# Define Functions

def SendMessage():
    now = datetime.now()
    command = "RemoteCommand 7642 page 224 \"YYYYMMDDHHMMSS" + now.strftime("%y%m%d%H%M%S") + "\""
    args = command.split()
    try:
        result = subprocess.run(args, check=True)
        logger.info(f"Sending message in slot {next_timeslot} to 0000224, type 6, func Alphanumeric: \"YYYYMMDDHHMMSS{now.strftime('%y%m%d%H%M%S')}\"")
    except subprocess.CalledProcessError as e:
        logger.error(f"Unable to send time message, please make sure you have enabled RF Remote Control in Admin->SystemManager")
        raise Exception(f'RemoteCommand failed with return code {e.returncode}')
    return()

def GetLogFile ():
    while True:
        try:
            date_today = datetime.utcnow().strftime('%Y-%m-%d')
            logfile_today = '/var/log/pi-star/DAPNETGateway-' + date_today + '.log'

            if not os.path.exists(logfile_today):
                list_of_files = glob.glob('/var/log/pi-star/DAPNETGateway-*.log')  # get list of all log files
                logfile_today = max(list_of_files, key=os.path.getctime)  # find the most recent log file

            # Remove old handler from the logger
            if logger.handlers:
                logger.removeHandler(logger.handlers[0])

            # Add new handler with the most recent log file
            handler = logging.FileHandler(logfile_today)
            formatter = logging.Formatter('M: %(asctime)s.%(msecs)03d %(message)s by %(name)s',"%Y-%m-%d %H:%M:%S")
            handler.setFormatter(formatter)
            logger.addHandler(handler)

            return logfile_today
        except ValueError:
            time.sleep(30)

def GetTimeslots():
    logfile_today = GetLogFile()
    
    search_phrase = 'Schedule information received: '
    while True:
        with open(logfile_today, 'r') as file:
            lines = file.readlines()
        # Reverse the list to start from the end of the file
        lines.reverse()
        for line in lines:
            if search_phrase in line:
                # Find the index of the search phrase in the line
                index = line.find(search_phrase)
                # Extract the 4 characters after "received: "
                timeslot = line[index + len(search_phrase):index + len(search_phrase) + 4]
                return timeslot
        # If no timeslot was found, wait for 5 seconds and then try again
        time.sleep(5)

def hex_to_bin(hex_string):
    return bin(int(hex_string, 16))[2:].zfill(16)

def calculate_timeslots(hex_string):
    timeslots = []
    for i in range(0, len(hex_string)):
        timeslot = int(hex_string[i], 16)
        timeslots.append((timeslot, calculate_timeslot_time(timeslot)))
    return timeslots

def calculate_timeslot_time(timeslot):
    now = time.time()  # current time in seconds since the epoch
    decis = now * 10  # convert to deciseconds
    current_slot = int((decis // 64) % 16)
    block_start = decis - (decis % 1024)  # start of the current block

    # calculate the start time of the next occurrence of the timeslot
    if timeslot < current_slot:
        block_start += 1024  # next block
    slot_start = block_start + timeslot * 64

    # convert back to a datetime object
    slot_time = datetime.utcfromtimestamp(slot_start / 10)
    return slot_time

# Setup logging
logger = logging.getLogger('POCSAGLocalTime')
logger.setLevel(logging.DEBUG)
logging.Formatter.converter = time.gmtime

# Main Loop
while True:
    hex_string = GetTimeslots()  # get the timeslot string from the log file
    timeslots = calculate_timeslots(hex_string)
    # sort the timeslots by time, and select the first one
    timeslots.sort(key=lambda x: x[1])
    next_timeslot, next_timeslot_time = timeslots[0]

    # wait until the next timeslot time
    while datetime.utcnow() < next_timeslot_time:
        time.sleep(1)

    SendMessage()

    # wait for 4 minutes before checking the log file and sending the next message
    time.sleep(4 * 60)

